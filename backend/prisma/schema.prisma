generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    Int                    @id @default(autoincrement())
  email                 String                 @unique
  name                  String?
  password              String?
  createdAt             DateTime               @default(now()) @map("created_at")
  updatedAt             DateTime               @updatedAt @map("updated_at")
  deletedAt             DateTime?              @map("deleted_at")
  kakaoId               String?                @unique @map("kakao_id")
  kakaoNickname         String?                @map("kakao_nickname")
  kakaoProfileImage     String?                @map("kakao_profile_image")
  kakaoConnectedAt      DateTime?              @map("kakao_connected_at")
  blogPosts             BlogPost[]
  businessInfo          BusinessInfo?
  cards                 Card[]
  creditAccount         CreditAccount?
  creditTransactions    CreditTransaction[]
  emailVerifications    EmailVerification[]
  keywordTrackings      KeywordTracking[]
  payments              Payment[]
  personas              Persona[]
  refreshTokens         RefreshToken[]
  subscriptionHistories SubscriptionHistory[]
  usageLogs             SubscriptionUsageLog[]
  subscriptions         UserSubscription[]

  @@index([deletedAt])
  @@map("users")
}

model BusinessInfo {
  id               Int      @id @default(autoincrement())
  businessName     String?  @map("business_name")
  businessNumber   String?  @map("business_number")
  businessOwner    String?  @map("business_owner")
  businessAddress  String?  @map("business_address")
  businessType     String?  @map("business_type")
  businessCategory String?  @map("business_category")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  userId           Int      @unique @map("user_id")
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("business_info")
}

model RefreshToken {
  id         Int      @id @default(autoincrement())
  token      String   @unique
  userId     Int      @map("user_id")
  expiresAt  DateTime @map("expires_at")
  createdAt  DateTime @default(now()) @map("created_at")
  deviceName String?  @map("device_name")
  ipAddress  String?  @map("ip_address")
  lastUsedAt DateTime @default(now()) @map("last_used_at")
  userAgent  String?  @map("user_agent")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model Persona {
  id             Int      @id @default(autoincrement())
  gender         String
  age            Int
  isMarried      Boolean  @map("is_married")
  hasChildren    Boolean  @map("has_children")
  occupation     String
  blogStyle      String   @map("blog_style")
  blogTone       String   @map("blog_tone")
  additionalInfo String?  @map("additional_info")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")
  userId         Int      @map("user_id")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("personas")
}

model BlogPost {
  id               Int        @id @default(autoincrement())
  keyword          String
  persona          Json
  postType         String     @map("post_type")
  subKeywords      String[]   @map("sub_keywords")
  length           Int        @default(300)
  count            Int        @default(1)
  additionalFields Json?      @map("additional_fields")
  status           PostStatus @default(PENDING)
  completedCount   Int        @default(0) @map("completed_count")
  targetCount      Int        @map("target_count")
  userId           Int        @map("user_id")
  createdAt        DateTime   @default(now()) @map("created_at")
  updatedAt        DateTime   @updatedAt @map("updated_at")
  creditCost       Int?       @map("credit_cost")
  posts            AIPost[]
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([status])
  @@map("blog_posts")
}

model AIPost {
  id               Int      @id @default(autoincrement())
  blogPostId       Int      @map("blog_post_id")
  content          String
  retryCount       Int      @default(0) @map("retry_count")
  lastError        String?  @map("last_error")
  createdAt        DateTime @default(now()) @map("created_at")
  completionTokens Int?     @map("completion_tokens")
  promptTokens     Int?     @map("prompt_tokens")
  totalTokens      Int?     @map("total_tokens")
  title            String?
  blogPost         BlogPost @relation(fields: [blogPostId], references: [id], onDelete: Cascade)

  @@index([blogPostId, createdAt])
  @@map("ai_posts")
}

model KeywordDate {
  id           Int        @id @default(autoincrement())
  keyword      String
  dateStr      String     @map("date_str")
  totalResults Int?       @map("total_results")
  fetchedAt    DateTime   @default(now()) @map("fetched_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  blogRanks    BlogRank[]

  @@unique([keyword, dateStr])
  @@index([dateStr])
  @@map("keyword_dates")
}

model BlogRank {
  id            Int         @id @default(autoincrement())
  keywordDateId Int         @map("keyword_date_id")
  rank          Int
  createdAt     DateTime    @default(now()) @map("created_at")
  blogId        Int         @map("blog_id")
  blog          Blog        @relation(fields: [blogId], references: [id], onDelete: Cascade)
  keywordDate   KeywordDate @relation(fields: [keywordDateId], references: [id], onDelete: Cascade)

  @@unique([keywordDateId, blogId])
  @@index([keywordDateId, blogId])
  @@map("blog_ranks")
}

model Blog {
  id            Int               @id @default(autoincrement())
  link          String            @unique
  title         String
  description   String?
  bloggerName   String            @map("blogger_name")
  bloggerLink   String            @map("blogger_link")
  postDate      String            @map("post_date")
  content       String?
  realUrl       String?           @map("real_url")
  lastFetchedAt DateTime?         @map("last_fetched_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")
  createdAt     DateTime          @default(now()) @map("created_at")
  summary       String?
  ranks         BlogRank[]
  tracking      KeywordTracking[]

  @@index([bloggerName])
  @@map("blogs")
}

model KeywordTracking {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  keyword         String
  myBlogUrl       String    @map("my_blog_url")
  isActive        Boolean   @default(true) @map("is_active")
  displayCount    Int       @default(40) @map("display_count")
  lastCollectedAt DateTime? @map("last_collected_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  bloggerName     String    @map("blogger_name")
  title           String?
  blogId          Int?      @map("blog_id")
  blog            Blog?     @relation(fields: [blogId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, keyword, myBlogUrl])
  @@index([userId, isActive])
  @@index([isActive])
  @@map("keyword_trackings")
}

model SubscriptionPlan {
  id                     Int                @id @default(autoincrement())
  name                   String             @unique
  displayName            String             @map("display_name")
  description            String?
  price                  Int                @default(0)
  yearlyPrice            Int?               @map("yearly_price")
  monthlyCredits         Int                @default(0) @map("monthly_credits")
  maxBlogPostsPerMonth   Int?               @map("max_blog_posts_per_month")
  maxPostLength          Int?               @map("max_post_length")
  maxKeywordTrackings    Int?               @map("max_keyword_trackings")
  maxPersonas            Int?               @map("max_personas")
  allowPriorityQueue     Boolean            @default(false) @map("allow_priority_queue")
  allowAdvancedAnalytics Boolean            @default(false) @map("allow_advanced_analytics")
  allowApiAccess         Boolean            @default(false) @map("allow_api_access")
  allowCustomPersonas    Boolean            @default(false) @map("allow_custom_personas")
  isActive               Boolean            @default(true) @map("is_active")
  sortOrder              Int                @default(0) @map("sort_order")
  createdAt              DateTime           @default(now()) @map("created_at")
  updatedAt              DateTime           @updatedAt @map("updated_at")
  subscriptions          UserSubscription[]

  @@index([isActive, sortOrder])
  @@map("subscription_plans")
}

model UserSubscription {
  id                Int                @id @default(autoincrement())
  userId            Int                @map("user_id")
  planId            Int                @map("plan_id")
  status            SubscriptionStatus @default(TRIAL)
  startedAt         DateTime           @default(now()) @map("started_at")
  expiresAt         DateTime           @map("expires_at")
  canceledAt        DateTime?          @map("canceled_at")
  autoRenewal       Boolean            @default(true) @map("auto_renewal")
  nextBillingDate   DateTime?          @map("next_billing_date")
  lastPaymentDate   DateTime?          @map("last_payment_date")
  lastPaymentAmount Int?               @map("last_payment_amount")
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @updatedAt @map("updated_at")
  plan              SubscriptionPlan   @relation(fields: [planId], references: [id])
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([status, expiresAt])
  @@map("user_subscriptions")
}

model SubscriptionUsageLog {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  resource  String
  amount    Int      @default(1)
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([resource, createdAt])
  @@map("subscription_usage_logs")
}

model Payment {
  id            Int           @id @default(autoincrement())
  userId        Int           @map("user_id")
  amount        Int
  currency      String        @default("KRW")
  status        PaymentStatus @default(PENDING)
  paymentMethod String?       @map("payment_method")
  transactionId String?       @unique @map("transaction_id")
  receiptUrl    String?       @map("receipt_url")
  refundedAt    DateTime?     @map("refunded_at")
  refundAmount  Int?          @map("refund_amount")
  refundReason  String?       @map("refund_reason")
  metadata      Json?
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([status])
  @@map("payments")
}

model Card {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  customerKey     String    @unique @map("customer_key")
  authenticatedAt DateTime? @map("authenticated_at")
  method          String?
  billingKey      String?   @map("billing_key")
  cardCompany     String?   @map("card_company")
  issuerCode      String?   @map("issuer_code")
  acquirerCode    String?   @map("acquirer_code")
  number          String?
  cardType        String?   @map("card_type")
  ownerType       String?   @map("owner_type")
  isAuthenticated Boolean   @default(false) @map("is_authenticated")
  isDefault       Boolean   @default(false) @map("is_default")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("cards")
}

model NicepayResult {
  id               Int       @id @default(autoincrement())
  moid             String    @unique
  signature        String
  userId           String    @map("user_id")
  resultCode       String?   @map("result_code")
  resultMsg        String?   @map("result_msg")
  msgSource        String?   @map("msg_source")
  amt              String?
  mid              String?
  buyerEmail       String?   @map("buyer_email")
  buyerTel         String?   @map("buyer_tel")
  buyerName        String?   @map("buyer_name")
  goodsName        String?   @map("goods_name")
  tid              String?
  authCode         String?   @map("auth_code")
  authDate         String?   @map("auth_date")
  payMethod        String?   @map("pay_method")
  cartData         String?   @map("cart_data")
  mallReserved     String?   @map("mall_reserved")
  cardCode         String?   @map("card_code")
  cardName         String?   @map("card_name")
  cardNo           String?   @map("card_no")
  cardQuota        String?   @map("card_quota")
  cardInterest     String?   @map("card_interest")
  acquCardCode     String?   @map("acqu_card_code")
  acquCardName     String?   @map("acqu_card_name")
  cardCl           String?   @map("card_cl")
  ccPartCl         String?   @map("cc_part_cl")
  couponAmt        String?   @map("coupon_amt")
  couponMinAmt     String?   @map("coupon_min_amt")
  pointAppAmt      String?   @map("point_app_amt")
  clickpayCl       String?   @map("clickpay_cl")
  multiCl          String?   @map("multi_cl")
  multiCardAcquAmt String?   @map("multi_card_acqu_amt")
  multiPointAmt    String?   @map("multi_point_amt")
  multiCouponAmt   String?   @map("multi_coupon_amt")
  multiDiscountAmt String?   @map("multi_discount_amt")
  rcptType         String?   @map("rcpt_type")
  rcptTid          String?   @map("rcpt_tid")
  rcptAuthCode     String?   @map("rcpt_auth_code")
  cardType         String?   @map("card_type")
  approveCardQuota String?   @map("approve_card_quota")
  pointCl          String?   @map("point_cl")
  vbankBankCode    String?   @map("vbank_bank_code")
  vbankBankName    String?   @map("vbank_bank_name")
  vbankNum         String?   @map("vbank_num")
  vbankExpDate     String?   @map("vbank_exp_date")
  vbankExpTime     String?   @map("vbank_exp_time")
  bankCode         String?   @map("bank_code")
  bankName         String?   @map("bank_name")
  cancelAmt        String?   @map("cancel_amt")
  cancelDate       String?   @map("cancel_date")
  cancelTime       String?   @map("cancel_time")
  cancelNum        String?   @map("cancel_num")
  remainAmt        String?   @map("remain_amt")
  errorCd          String?   @map("error_cd")
  errorMsg         String?   @map("error_msg")
  createdAt        DateTime  @default(now()) @map("created_at")
  approvedAt       DateTime? @map("approved_at")

  @@map("nicepay_results")
}

model CreditAccount {
  id                  Int                 @id @default(autoincrement())
  userId              Int                 @unique @map("user_id")
  subscriptionCredits Int                 @default(0) @map("subscription_credits")
  purchasedCredits    Int                 @default(0) @map("purchased_credits")
  bonusCredits        Int                 @default(0) @map("bonus_credits")
  totalCredits        Int                 @default(0) @map("total_credits")
  lastUsedAt          DateTime?           @map("last_used_at")
  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime            @updatedAt @map("updated_at")
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions        CreditTransaction[]

  @@index([userId])
  @@map("credit_accounts")
}

model CreditTransaction {
  id            Int                   @id @default(autoincrement())
  accountId     Int                   @map("account_id")
  userId        Int                   @map("user_id")
  type          CreditTransactionType @map("type")
  amount        Int
  balanceBefore Int                   @map("balance_before")
  balanceAfter  Int                   @map("balance_after")
  creditType    CreditType            @map("credit_type")
  description   String?
  referenceType String?               @map("reference_type")
  referenceId   Int?                  @map("reference_id")
  metadata      Json?
  expiresAt     DateTime?             @map("expires_at")
  createdAt     DateTime              @default(now()) @map("created_at")
  account       CreditAccount         @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user          User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([accountId, createdAt])
  @@index([type, createdAt])
  @@map("credit_transactions")
}

model SubscriptionHistory {
  id             Int                 @id @default(autoincrement())
  userId         Int                 @map("user_id")
  subscriptionId Int?                @map("subscription_id")
  planId         Int                 @map("plan_id")
  planName       String              @map("plan_name")
  planPrice      Int                 @map("plan_price")
  action         SubscriptionAction  @map("action")
  oldStatus      SubscriptionStatus? @map("old_status")
  newStatus      SubscriptionStatus? @map("new_status")
  startedAt      DateTime?           @map("started_at")
  expiresAt      DateTime?           @map("expires_at")
  creditsGranted Int?                @map("credits_granted")
  paymentId      Int?                @map("payment_id")
  reason         String?
  metadata       Json?
  createdAt      DateTime            @default(now()) @map("created_at")
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([subscriptionId])
  @@map("subscription_histories")
}

model EmailVerification {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  code      String
  expiresAt DateTime @map("expires_at")
  attempts  Int      @default(0)
  userId    Int?     @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([expiresAt])
  @@map("email_verifications")
}

model PromptLog {
  id               Int      @id @default(autoincrement())
  userId           Int      @map("user_id")
  blogPostId       Int?     @map("blog_post_id")
  aiPostId         Int?     @map("ai_post_id")
  systemPrompt     String   @map("system_prompt")
  userPrompt       String   @map("user_prompt")
  fullPrompt       String?  @map("full_prompt")
  model            String   @default("gpt-4")
  temperature      Float?
  maxTokens        Int?     @map("max_tokens")
  promptTokens     Int?     @map("prompt_tokens")
  completionTokens Int?     @map("completion_tokens")
  totalTokens      Int?     @map("total_tokens")
  response         String?
  responseTime     Int?     @map("response_time")
  success          Boolean  @default(true)
  errorMessage     String?  @map("error_message")
  purpose          String?
  metadata         Json?
  createdAt        DateTime @default(now()) @map("created_at")

  @@index([userId, createdAt])
  @@index([blogPostId])
  @@index([aiPostId])
  @@index([createdAt])
  @@map("prompt_logs")
}

model Contact {
  id          Int             @id @default(autoincrement())
  name        String
  email       String
  phone       String?
  subject     String
  message     String
  category    ContactCategory @default(GENERAL)
  status      ContactStatus   @default(PENDING)
  adminNote   String?         @map("admin_note")
  respondedAt DateTime?       @map("responded_at")
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  @@index([email])
  @@index([status, createdAt])
  @@index([category])
  @@map("contacts")
}

model SchedulerLog {
  id             Int                 @id @default(autoincrement())
  taskName       String              @map("task_name")
  status         SchedulerTaskStatus @default(RUNNING)
  startedAt      DateTime            @default(now()) @map("started_at")
  completedAt    DateTime?           @map("completed_at")
  duration       Int?                @map("duration")
  totalItems     Int?                @map("total_items")
  processedItems Int?                @default(0) @map("processed_items")
  successItems   Int?                @default(0) @map("success_items")
  failedItems    Int?                @default(0) @map("failed_items")
  message        String?
  metadata       Json?
  createdAt      DateTime            @default(now()) @map("created_at")
  updatedAt      DateTime            @updatedAt @map("updated_at")

  @@index([taskName, startedAt])
  @@index([status, startedAt])
  @@index([startedAt])
  @@map("scheduler_logs")
}

enum PostStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum CreditTransactionType {
  SUBSCRIPTION_GRANT
  PURCHASE
  BONUS
  PROMO
  USAGE
  REFUND
  EXPIRE
  ADMIN_ADJUSTMENT
}

enum CreditType {
  SUBSCRIPTION
  PURCHASED
  BONUS
}

enum SubscriptionAction {
  CREATED
  RENEWED
  UPGRADED
  DOWNGRADED
  CANCELLED
  EXPIRED
  REACTIVATED
  PAYMENT_FAILED
}

enum ContactCategory {
  GENERAL
  TECHNICAL
  BILLING
  FEATURE
  BUG
  PARTNERSHIP
  OTHER
}

enum ContactStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SchedulerTaskStatus {
  RUNNING
  COMPLETED
  FAILED
  PARTIAL
}
